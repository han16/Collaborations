---
title: "06/04 2025"
output:
  workflowr::wflow_html:
    code_folding: hide
    toc: true
date: "2025-06-04"
---




```{r, echo=F, message=F, warning=F, results=F}
library(rprojroot)
root <- rprojroot::find_rstudio_root_file()
source(file.path(root, "analysis/Rfunctions.R"))
root <- rprojroot::find_rstudio_root_file()
```




```{r, message=F, warning=F, results=F}
data_raw=multiplesheets((file.path(root, "..\\2025\\202506\\Shikha\\Dr. Gupta Endo Data.xlsx")))
endo_cases=data_raw$EndoCases
endo_cases=endo_cases %>% mutate(tooth=paste0(endo_cases$Patient, ":", endo_cases$Site))

post_endo_tx=data_raw$`Post Endo TX`
post_endo_tx=post_endo_tx %>% mutate(tooth=paste0(post_endo_tx$Patient, ":", post_endo_tx$Site))
```


## step 1: root canal 


```{r, message=F, warning=F}
# Create a data frame
root_canal_codes <- data.frame(
  Code = c("D3310", "D3320", "D3330"),
  Description = c(
    "anterior RCT",
    "bicuspid RCT",
    "molar RCT"
  )
)

# Display table
knitr::kable(root_canal_codes, caption = "root canal Codes", align = 'lc')
```




```{r, message=F, warning=F}


endo_cases_with_root_canal=endo_cases %>% filter(Procedure %in% root_canal_codes$Code)%>%
  group_by(tooth) %>%
  arrange(Date) %>%
  slice_tail(n = 1) %>%  # Keeps the last root canal date
  ungroup()

endo_cases_with_root_canal %>%
datatable(extensions = 'Buttons',
          caption = "", 
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),
                                             c(10,25,50,"All"))))

```


* only keep the latest root canal if the tooth has multiple root canals. 




```{r, message=F, warning=F}
# Count the number of each Procedure
procedure_counts <- endo_cases_with_root_canal %>%dplyr::count(Procedure)

# Bar plot
ggplot(procedure_counts, aes(x = Procedure, y = n, fill=Procedure)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = n), vjust = -0.5, size = 4) +
  labs(
    title = "",
    x = "Procedure Code",
    y = "Count"
  ) +
  theme_minimal() +
  theme(
    text = element_text(size = 14),
    plot.title = element_text(hjust = 0.5, face = "bold")
  )

```





## step 2: initial treatment 


```{r, message=F, warning=F}
# Create a data frame of Final Restoration codes
final_restoration_codes <- data.frame(
  Code = c(
    "D2390", "D2391", "D2392", "D2393", "D2394",
    "D2650", "D2651", "D2652", "D2662", "D2663", "D2664",
    "D2710", "D2712", "D2720", "D2721", "D2722",
    "D2910", "D2915", "D2920", "D2932", "D2933",
    "D2940", "D2949", "D2950", "D2951", "D2952", "D2954",
    "D6068", "D6069", "D6070", "D6071", "D6072", "D6073", "D6074",
    "D6545", "D6548", "D6611",
    "D6710", "D6720", "D6721", "D6722",
    "D6740", "D6750", "D6780", "D6790", "D6793",
    "D6930", "D6971"
  ),
  Description = c(
    "Resin-based comp crown, ant.",
    "Resin-based comp - 1 surface, posterior",
    "Resin-based comp - 2 surfaces, posterior",
    "Resin-based comp - 3 surfaces, posterior",
    "Resin-based comp - 4+ surfaces, posterior",
    "Inlay - resin - 1 surface",
    "Inlay - resin - 2 surfaces",
    "Inlay - resin - 3 or more",
    "Onlay - resin - 2 surfaces",
    "Onlay - resin - 3 surfaces",
    "Onlay - resin - 4 or more",
    "Resin crown - laboratory",
    "Crown - 3/4 resin-based comp",
    "Resin crown - high noble metal",
    "Resin crown - predominately base metal",
    "Resin crown - noble metal",
    "Recement/re-bond inlay/onlay",
    "Recement cast or prefab post",
    "Recement/re-bond crown",
    "Prefabricated resin crown",
    "Prefab stainless steel crown w/ resin window",
    "Protective restoration",
    "Restorative foundation/indirect restoration",
    "Core buildup - including pins",
    "Pin retention - per tooth",
    "Post & core, indirect fabrication",
    "Prefab post and core",
    "Abutment-retainer, porcelain/ceramic FPD",
    "Abutment-ret., PFM FPD, high noble",
    "Abutment-ret., PFM FPD, base metal",
    "Abutment-ret., PFM FPD, noble metal",
    "Abut-ret., cast metal, high noble",
    "Abut-ret., cast metal, base metal",
    "Abut-ret., cast metal, noble metal",
    "Retainer, metal, resin-bonded FPD",
    "Retainer, porcelain/ceramic, bonded FPD",
    "Retainer onlay, high noble metal, 3+ surfaces",
    "Crown - indirect resin-based",
    "Crown - resin, high noble metal",
    "Crown - resin, predominately base metal",
    "Crown - resin, noble metal",
    "Retainer crown - porcelain/ceramic",
    "Retainer crown - porcelain fused to high noble metal",
    "Retainer crown - 3/4 cast, high noble metal",
    "Retainer crown - full cast, high noble metal",
    "Provisional retainer crown",
    "Recement/re-bond FPD",
    "Cast post - part of FPD retainer"
  )
)

knitr::kable(final_restoration_codes, caption = "final restoration codes", align = 'lc')

post_endo_tx_with_final_restoration_codes=post_endo_tx %>% filter(Procedure %in% final_restoration_codes$Code ) %>% filter(`Endo Check`=="Yes")


```




## time period between root canal and inital treatment 



```{r, message=F, warning=F}
library(dplyr)
library(DT)

# Ensure Date columns are Date type
endo_cases_with_root_canal$Date <- as.Date(endo_cases_with_root_canal$Date)
post_endo_tx_with_final_restoration_codes$Date <- as.Date(post_endo_tx_with_final_restoration_codes$Date)

# Step 1: Rename columns for clarity
endo_root <- endo_cases_with_root_canal %>%
  rename(
    root_canal_date = Date,
    root_canal_procedure = Procedure
  )

restoration <- post_endo_tx_with_final_restoration_codes %>%
  rename(
    restoration_date = Date,
    restoration_procedure = Procedure
  )

# Step 2: Perform inner join on tooth, retaining all necessary columns explicitly
joined <- endo_root %>%
  select(Patient, tooth, root_canal_date, root_canal_procedure) %>%
  inner_join(restoration %>% select(tooth, restoration_date, restoration_procedure),
             by = "tooth")

# Step 3: Filter restorations that occurred *after* root canal
after_root_canal <- joined %>%
  filter(restoration_date > root_canal_date)

# Step 4: Group by root canal event (Patient + tooth + date) and get earliest restoration
first_restoration <- after_root_canal %>%
  group_by(Patient, tooth, root_canal_date) %>%
  arrange(restoration_date) %>%
  slice(1) %>%
  ungroup()

# Step 5: Calculate time difference and select output columns
endo_with_tx_time <- first_restoration %>%
  mutate(
    time_between_days = as.numeric(restoration_date - root_canal_date)
  ) %>%
  select(
    Patient,
    tooth,
    root_canal_date,
    root_canal_procedure,
    first_restoration_date = restoration_date,
    first_restoration_procedure = restoration_procedure,
    time_between_days
  )

endo_with_tx_time %>%
  datatable(
    extensions = 'Buttons',
    options = list(
      dom = 'Blfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      lengthMenu = list(c(10, 25, 50, -1), c(10, 25, 50, "All"))
    )
  )


```


* if a tooth has multiple restorations after root canal, keep the earliest one only. 





```{r, message=F, warning=F}
library(dplyr)
library(lubridate)

# Ensure Date columns are Date type
endo_cases_with_root_canal$Date <- as.Date(endo_cases_with_root_canal$Date)
post_endo_tx_with_final_restoration_codes$Date <- as.Date(post_endo_tx_with_final_restoration_codes$Date)

# Rename for clarity
endo <- endo_cases_with_root_canal %>%
  rename(endo_date = Date,
         endo_procedure = Procedure)

resto <- post_endo_tx_with_final_restoration_codes %>%
  rename(restoration_date = Date,
         restoration_procedure = Procedure)

# Perform many-to-many join by "tooth"
combined <- inner_join(endo, resto, by = "tooth") %>%
  # Optional: restrict to matching Patient as well
  filter(Patient.x == Patient.y) %>%
  mutate(time_between_days = as.numeric(restoration_date - endo_date)) %>%
  select(
    Patient = Patient.x,
    tooth,
    endo_date,
    endo_procedure,
    restoration_date,
    restoration_procedure,
    time_between_days
  ) %>%
  arrange(Patient, tooth, endo_date, restoration_date)

# View results

combined %>%
  datatable(
    extensions = 'Buttons',
    caption = "",
    options = list(
      dom = 'Blfrtip',
      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
      lengthMenu = list(c(10, 25, 50, -1), c(10, 25, 50, "All"))
    )
  )

```





## step 3: post treatment 


```{r, message=F, warning=F}
# Create a data frame
failure_codes <- data.frame(
  Code = c("D3346", "D3347", "D3348", "D3421", "D3425", "D3410", "D3426",
           "D3430", "D3450", "D3470", "D3505", "D3920", "D7140", "D7210"),
  Description = c(
    "Anterior-retreat prev. rt. canal",
    "Bicuspid retreat prev. rt. canal",
    "Molar retreat prev. rt. canal",
    "Apicoectomy - bicuspid (1st root)",
    "Apicoectomy - molar (1st root)",
    "Apicoectomy - anterior",
    "Apicoectomy - additional roots",
    "Retrograde filling - per root",
    "Root amputation - per root",
    "Intentional reimplantation",
    "Surgical exposure of root surface w/o apicoectomy",
    "Hemisection, incl. root removal",
    "Extraction",
    "Surgical removal of erupted tooth"
  )
)

# Display table
knitr::kable(failure_codes, caption = "Failure-related Procedure Codes", align = 'lc')

```




```{r, message=F, warning=F}

# Step 1: Define the failure-related procedure codes
failure_codes <- c(
  "D3346", "D3347", "D3348", "D3421", "D3425",
  "D3410", "D3426", "D3430", "D3450", "D3470",
  "D3505", "D3920", "D7140", "D7210"
)

# Step 2: Extract only failure events from all procedures
# all_procedures must include: Patient, tooth, Date, Procedure
failure_events <- post_endo_tx %>% filter(`Endo Check`=="Yes") %>% 
  filter(Procedure %in% failure_codes) %>%
  rename(failure_date = Date, failure_code = Procedure) %>%
  select(Patient, tooth, failure_date, failure_code)

failure_events$failure_date=as.Date(failure_events$failure_date)

# Step 3: Join with endo_with_tx_time and filter for valid failures (after restoration)
endo_with_failure <- endo_with_tx_time %>%
  left_join(failure_events, by = c("Patient", "tooth")) %>%
  filter(is.na(failure_date) | failure_date >= first_restoration_date) %>%  # allow NA for no failure
  group_by(Patient, tooth, root_canal_date) %>%
  arrange(failure_date) %>%
  slice(1) %>%  # earliest failure (or NA)
  ungroup() %>%
  mutate(
    survival_days = as.numeric(failure_date - first_restoration_date),
    survival_weeks = round(survival_days / 7,2), 
    survival_months = round(survival_days / 30.44,2), 
    survival_years = round(survival_days / 365.25, 2)
  )

endo_with_failure%>%
datatable(extensions = 'Buttons',
          caption = "", 
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),
                                             c(10,25,50,"All"))))
```






## survival analysis 

```{r, message=F, warning=F, eval=T}
# Load required libraries
library(survival)
library(survminer)

# Step 1: Prepare the data
survival_data <- endo_with_failure %>%
  mutate(
    # Event flag: 1 = failed, 0 = censored
    event = ifelse(is.na(failure_date), 0, 1),
    # Time to event in days
    survival_days = as.numeric(failure_date - first_restoration_date)
  )

# Step 2: Create a Surv object
surv_object <- Surv(time = survival_data$survival_days, event = survival_data$event)

# Step 3: Fit Kaplan-Meier survival model
km_fit <- survfit(surv_object ~ 1)

# Step 4: Plot Kaplan-Meier survival curve
ggsurvplot(
  km_fit,
  data = survival_data,  # ✅ This solves the error
  conf.int = TRUE,
  xlab = "Days since first restoration",
  ylab = "Tooth survival probability",
  title = "Kaplan-Meier Survival Curve of Root Canal Treated Teeth",
  surv.median.line = "hv",
  risk.table = TRUE,
  risk.table.height = 0.25
)


```


