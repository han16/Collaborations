---
title: "Latent Class longitudinal data analysis"
author: "Shengtong Han"
date: ""
output: html_document
---

Review R for latent class growth analysis (LCGA) and/or growth mixture models (GMMs). 



## lcmm-R package 

[lcmm R package can fit both GMM and LCGA](https://github.com/CecileProust-Lima/lcmm/issues/44)

* it handles both continuous longitudinal outcomes (Gaussian or non-Gaussian) as well as bounded quantitative, discrete and ordinal longitudinal outcomes

* program also works when no random-effect is included

### mixed models 

####  linear mixed model 

As in [Laird and Ware (1982)](https://www.jstor.org/stable/2529876?origin=crossref&seq=1#metadata_info_tab_contents), define linear mixed model 

$$Y_{ij}=X_{Li}(t_{ij})^T\beta+Z_i(t_{ij})^Tu_i+w_i(t_{ij})+\epsilon_{ij}$$

* $Y_{ij}$ outcome value of subject $i$ from accasion $j$.
* $X_{Li}(t_{ij}), Z_i(t_{ij})$ two vector of covariates 
* $\beta$ fixed efffect 
* $u_i$, random effect, follows $N(0, B)$
* $\epsilon_i \sim N(0, \sigma_{\epsilon}^2)$
* $w_i(.)$, zero mean Gaussian stochastic process, with $cov(w_i(t), w_i(s))=\sigma_w^2min(t,s)$

Aim: to estimate $(\beta, vec(B), \sigma_{\epsilon}^2, \sigma_w^2)$. 

#### Latent process mixed model 

Define it without measurement error 

$$\Lambda_{i}(t)=X_{Li}(t)^T\beta+Z_i(t)^Tu_i+w_i(t)$$
to define a flexible nonlinear measurement error model 

$$Y_{ij}=H(\Lambda_i(t_{ij})+\epsilon_{ij}, \eta)$$
$H$ is a paramerized link function and for a quantitative marker, $H^{-1}$ could be a  monotone increasing function. 

### Example 

This example is from [here](https://www.rdocumentation.org/packages/lcmm/versions/1.8.1.1/topics/lcmm)

```{r, echo=T, message=F, warning=F, eval=T}
library(lcmm)
#### Estimation of homogeneous mixed models with different assumed link
#### functions, a quadratic mean trajectory for the latent process and 
#### correlated random intercept and slope (the random quadratic slope 
#### was removed as it did not improve the fit of the data).
#### -- comparison of linear, Beta and 3 different splines link functions --
# linear link function
m10<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="linear")
summary(m10)
```
```{r, echo=T, message=F, warning=F}
# Beta link function
m11<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="beta")
summary(m11)
plot(m11,which="linkfunction",bty="l")
```

```{r,echo=T, message=F, warning=F}
# I-splines with 3 equidistant nodes
m12<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="3-equi-splines")
summary(m12)
# I-splines with 5 nodes at quantiles
m13<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="5-quant-splines")
summary(m13)
# I-splines with 5 nodes, and interior nodes entered manually
m14<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="5-manual-splines",intnodes=c(10,20,25))
summary(m14)
plot(m14,which="linkfunction",bty="l")
```

```{r, echo=T, message=F, warning=F, cache=T}

# Thresholds
# Especially for the threshold link function, we recommend to estimate 
# models with increasing complexity and use estimates of previous ones 
# to specify plausible initial values (we remind that estimation of
# models with threshold link function involves a computationally demanding 
# numerical integration -here of size 3)
m15<-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1
,data=data_lcmm,link="thresholds",maxiter=100,
B=c(-0.8379, -0.1103,  0.3832,  0.3788 , 0.4524, -7.3180,  0.5917,  0.7364,
 0.6530, 0.4038,  0.4290,  0.6099,  0.6014 , 0.5354 , 0.5029 , 0.5463,
 0.5310 , 0.5352, 0.6498,  0.6653,  0.5851,  0.6525,  0.6701 , 0.6670 ,
 0.6767 , 0.7394 , 0.7426, 0.7153,  0.7702,  0.6421))
summary(m15)
plot(m15,which="linkfunction",bty="l")
```

```{r, echo=T, message=F, warning=F}
#### Plot of estimated different link functions:
#### (applicable for models that only differ in the "link function" used. 
####  Otherwise, the latent process scale is different and a rescaling
####  is necessary)
plot(m10,which="linkfunction",col=1,xlab="latent process",ylab="marker",
bty="l",xlim=c(-10,5),legend=NULL)
plot(m11,which="linkfunction",add=TRUE,col=2,legend=NULL)
plot(m12,which="linkfunction",add=TRUE,col=3,legend=NULL)
plot(m13,which="linkfunction",add=TRUE,col=4,legend=NULL)
plot(m14,which="linkfunction",add=TRUE,col=5,legend=NULL)
plot(m15,which="linkfunction",add=TRUE,col=6,legend=NULL)
legend(x="bottomright",legend=c("linear","beta","spl_3e","spl_5q","spl_5m","thresholds"),
col=1:6,lty=1,inset=.02,box.lty=0)
```

```{r, echo=T, message=F, warning=F}
#### Estimation of 2-latent class mixed models with different assumed link 
#### functions with individual and class specific linear trend
#### for illustration, only default initial values where used but other
#### sets of initial values should also be tried to ensure convergence 
#### towards the golbal maximum
# Linear link function
m20<-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="linear",B=c(-0.98,0.79,-2.09,
-0.81,0.19,0.55,24.49,2.24))
summary(m20)
postprob(m20)
```

```{r, echo=T, message=F, warning=F}
# Beta link function
m21<-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="beta",B=c(-0.1,-0.56,-0.4,-1.77,
0.53,0.14,0.6,-0.83,0.73,0.09))
summary(m21)
postprob(m21)
```

```{r, echo=T, message=F, warning=F}
# I-splines link function (and 5 nodes at quantiles)
m22<-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="5-quant-splines",B=c(0.12,0.63,
-1.76,-0.39,0.51,0.13,-7.37,1.05,1.28,1.96,1.3,0.93,1.05))
summary(m22)
postprob(m22)

data <- data_lcmm[data_lcmm$ID==193,]
plot(predictL(m22,var.time="Time",newdata=data,bty="l"))

```

#### Reference 

* [Estimation of Extended Mixed Models Using Latent Classes and Latent Processes: The R Package lcmm](https://www.jstatsoft.org/article/view/v078i02)


## kml3d 

a new implementation of k-means for longitudinal data (or trajectories).

* can deal with missing value (how?)
* By default, nbClusters is 2:6, with the maximum of 26, 20 times each 
* k-means is a "hill-climbing" algorithm, no guarantee of optimality

### Example 

#### Example 1

This is the [example](https://www.rdocumentation.org/packages/kml3d/versions/2.4.2/topics/kml3d)

```{r, echo=T, message=F, warning=F}
library(kml3d)
### Generation of some data
cld1 <- generateArtificialLongData3d(15)
cld1
```

```{r, echo=T, message=F, warning=F}
### We suspect 2, 3, 4 or 5 clusters, we want 3 redrawing.
###   We want to "see" what happen (so toPlot="both")
kml3d(cld1,2:5,3,toPlot="both")


### 3 seems to be the best.
###   We don't want to see again, we want to get the result as fast as possible.
###   Just, to check the overall process, we plot the criterion evolution
kml3d(cld1,3,10,toPlot="criterion")

```

#### Example 2 


```{r, echo=T, warning=F, message=F}
library(kml3d)
# NOT RUN {
### 1. Data Preparation
data(pregnandiol)
head(pregnandiol)
names(pregnandiol)
cld3dPregTemp <- cld3d(pregnandiol,timeInData=list(temp=1:30*2,preg=1:30*2+1))

### 2. Building "optimal" clusteration (with only 2 redrawings)
###    Real analysis needs at least 20 redrawings
kml3d(cld3dPregTemp,3:5,nbRedrawing=2,toPlot="both")

### 3. Exporting results
try(choice(cld3dPregTemp))

### 4. Visualizing in 3D
plotMeans3d(cld3dPregTemp,4)
# }
```